### Capturing re-factoring requirements

Developers want to re-factor, and they want to improve things in their code. But if you ask them, *"Where are the things that you want to re-factor now?"*, or if, from a management point of view, you say, *"You can spend X amount of time re-factoring, but what exactly will you do?"*, in most cases they won't be able to tell you. 

The reason for this is there tends to be a threshold for issues added to the bug-tracking system. And the problem with that is many re-factored items don't get captured in those bug-tracking systems.

I prefer to have very small tickets, or to have a specific bug-tracking solution or project that captures all the quality. You can use tickets that are smaller than ten or 15 minutes to capture the quality.

These are all non-functional requirements, and they represent incremental gains: they are the 0.1% - 1% improvement that ultimately makes the application better and easier to maintain.

If, every time you see something in a code, or every time you think of a way to improve it, and you capture it, whether as a developer or as a manager, then you create a nice pipeline of work that you can use first thing in the morning when you are warming up for development. New developers should start here when they join the team. 

When a new dev joins the team, they should be ready to submit pull requests and push to production within the first couple of days. They should address the little issues, and they should progress gradually from typos to re-factoring. They should be able to change certain things without affecting the application; this is what re-factoring should be.

Re-factoring and coding are the best ways for new devs to learn how the application works. Writing code that will go into the application means that new devs become productive much faster. This is a great way for them to learn how to do their job. 

So, by capturing these tickets, you not only create a much better representation of reality, but you capture knowledge that would otherwise be lost when the developers move to newer teams.  You also make the new members of the team more productive, and you create a much better way to learn how the application works.
